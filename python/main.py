#⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⡤⠤⢤⣤⣀⠀⢀⣀⠀⣠⠤⠤⣤⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
#⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠶⠛⢉⠁⣀⣤⠠⠀⡀⠄⡀⠈⠉⡀⠀⠄⡥⣤⡀⠉⠛⠶⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
#⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠞⠉⠛⠛⠶⣄⡀⢀⣠⠞⠋⢀⠀⣢⠴⠋⡁⠠⠐⠠⠐⠀⡀⠁⢂⠀⠡⠈⠄⡀⠉⠷⣦⠀⠠⠙⠳⣄⡀⠀⠀⠀⠀⠀⣀⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀
#⠀⠀⠀⠀⠀⠀⠀⠀⣸⠇⠀⠈⠤⠁⠂⢈⣭⠚⠁⢀⠂⣠⠞⠅⡀⢂⠐⠁⡈⠄⡾⠁⠀⢷⡀⠌⠠⢁⠂⠄⠡⠀⠌⢡⡀⢡⠀⠀⡙⢦⡀⢀⡴⠛⢉⠀⢈⢃⠀⠀⠀⠀⠀⠀⠀
#⠀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠄⣡⠖⠛⢻⠞⠁⠀⠌⢀⡼⠁⠌⡐⠀⠂⢈⠐⢠⠞⠀⠌⢀⠀⠻⣆⡁⠂⡐⢀⠁⡀⠂⠀⠹⣆⠂⡁⢀⠀⣿⣟⠀⠌⠠⠈⡀⠘⣧⠀⠀⠀⠀⠀⠀
#⠀⠀⠀⠀⠀⠀⠀⢸⡇⢀⡼⠃⢈⣴⠋⢀⠂⡁⢂⠞⡀⠁⠂⠄⠡⠈⢀⡴⠃⠀⠀⠀⠀⠄⠀⠘⢧⡐⢀⠀⢂⠐⠠⢁⠀⡘⢧⡐⢀⠂⠘⢞⠷⡤⣅⡐⠠⢀⠸⣇⠀⠀⠀⠀⠀
#⠀⠀⠀⠀⠀⠀⠀⣿⠁⡼⢁⢠⡾⠁⡀⢂⠐⢠⠏⠠⠐⢈⠐⡈⢐⡼⠋⠀⢀⠐⠈⠀⠈⡀⠄⠀⠠⠙⢦⣈⠠⠈⡐⠀⡐⠠⠘⣧⠀⠌⡐⠈⢿⡙⣄⠉⢳⣄⠀⣿⠀⠀⠀⠀⠀
#⠀⠀⠀⠀⠀⠀⠀⣿⢸⠇⢀⣼⠃⢀⠠⠀⠄⣼⠀⠃⠠⠀⠤⣠⣟⣀⠀⠀⠀⠀⠀⠀⠠⠀⠀⢀⠀⡤⠤⠻⣧⡤⠄⠠⠀⢃⠀⢻⡀⠄⡀⢃⠀⢧⡀⢄⠀⢻⣤⢸⡇⠀⠀⠀⠀
#⠀⠀⠀⠀⠀⠀⢰⣧⡟⠀⡾⠁⢀⠂⠄⠁⣸⠁⡀⠂⢷⣴⡋⠐⢀⣨⡷⠀⠈⠀⠀⠀⠀⠀⠐⠀⠺⢥⣠⣁⣀⡹⢦⡥⠈⠄⢂⠀⡇⢂⠐⠀⠂⠘⣧⢸⣆⠠⠀⠈⣷⠀⠀⠀⠀
#⠀⠀⠀⠀⠀⠀⢸⡿⠀⣸⠃⢀⠂⠠⢈⢠⡏⠠⢐⡴⠋⠀⠈⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀⢀⠀⠀⡀⠀⠠⠀⠀⠙⠳⣌⠠⠀⢻⢀⠀⠂⠁⠄⠘⢺⣿⣄⠈⠄⢿⡄⠀⠀⠀
#⠀⠀⠀⠀⠀⠀⢸⠇⢠⠇⠀⠂⠄⡁⠂⣸⣠⠔⠋⠀⠀⡀⠐⣄⣀⣂⠀⠀⠠⠐⠀⠀⠄⠂⠁⡀⢀⡥⠖⣒⣀⣁⣴⠂⠀⠈⠳⢦⣸⠀⢂⠡⢈⠠⠈⢸⡏⣟⡄⠠⠸⣇⠀⠀⠀
#⠀⠀⠀⠀⠀⠀⣿⠀⡟⠀⠌⡐⠀⡂⠁⣿⠁⠀⣀⣷⣦⣿⣷⣶⣶⣬⣙⠀⠀⠂⠀⠀⡀⠌⠀⡀⠠⠶⣻⣿⣿⣿⣿⣿⣷⣦⣤⠤⢹⠀⢂⠐⡀⢂⠡⠀⣧⣯⣧⠐⠀⣿⠀⠀⠀
#⠀⠀⠀⠀⠀⢸⡇⢸⢣⠈⠀⠄⡁⠄⢶⣿⣳⡾⠋⣱⣿⣿⣿⣿⣿⣿⣮⠁⠀⠁⠈⠀⠀⠠⠀⠀⠀⣼⣿⡿⣿⣻⠿⣿⣿⡌⠻⣷⣾⠆⠂⠐⠀⢂⠐⡀⢻⣿⣻⡄⠀⠹⠆⠀⠀
#⠀⠀⠀⠀⠀⣼⠀⡟⡏⠐⠈⢀⠀⠂⠄⢿⠻⠆⠀⢿⡟⠁⠻⠞⢁⣹⠟⠀⠀⠠⠀⠖⠀⢀⠀⠄⠀⠙⠿⢠⣭⣍⣠⣸⠟⠁⡈⢡⡇⠀⠐⠀⡈⠀⢂⢐⢸⣿⣳⣧⣈⣐⣀⡀⠀
#⠀⠀⠀⠀⠀⡟⢸⡇⡇⢈⠐⡀⢠⡂⠄⠸⡇⡐⢈⢤⢉⡉⠩⢉⠁⡀⠀⠀⠀⠄⠐⠀⡐⠀⡀⠀⠈⠠⠐⢠⠠⡢⢅⡦⢨⠐⢀⡞⢀⠈⡐⠠⠐⢈⠀⢸⢸⡏⠉⠉⠉⢉⣉⣉⣉
#⠖⠒⠒⠚⠓⠛⢹⢃⡇⠂⠄⡐⠈⣷⡈⠄⢻⡄⢂⢎⠲⢉⠒⡀⢂⠐⠀⠂⢁⠠⠈⠀⠀⠄⢀⡄⠈⠄⢁⠂⡐⡁⠎⡔⠡⢈⡞⢠⡿⠀⠄⠡⠈⠄⠈⡿⢸⣷⣞⢿⡻⣟⡻⣏⡟
#⢿⡻⢿⣻⢶⡶⣾⠄⡇⢐⠀⡀⠡⠈⢷⣦⣀⣹⢦⠀⠅⢊⠐⠀⡀⠂⠀⠀⢈⠙⠓⠀⠘⠛⠉⠀⠠⢈⠀⠄⠐⠀⢂⠐⠰⡭⠖⢳⠇⣸⠂⠁⠌⠐⣸⠇⣾⢳⡎⣷⡹⠎⠓⠉⠈
#⣳⣝⢧⣛⢮⡳⣽⡆⣿⠨⣇⣠⠶⡛⠭⡉⣍⠹⣈⠛⡛⠶⢦⣅⡀⠀⢀⠀⠂⠀⠀⠡⠀⠂⠀⢈⣤⠶⢖⡛⣋⠚⡉⢇⡙⠆⡤⢷⢾⡇⠐⢨⠀⣴⡿⢠⡟⢋⠉⢁⣀⣤⣤⠶⠒         by d3rrk1a
#⠶⢤⣬⠉⠙⠛⠻⣇⠘⢣⡞⡡⢎⠰⡑⠰⣀⠣⢄⠣⡘⢌⠒⡌⠛⢷⣤⠀⠀⠄⠂⡀⠁⣠⡾⢋⠆⣉⠆⡰⢁⠚⣈⠆⣘⠰⢌⠢⡙⢧⡞⢁⣾⡇⢁⣾⡟⣿⣟⡟⣯⣻⢸⠀⠀             <3
#⠀⠀⠀⠀⣽⢉⣿⣿⣶⡟⠤⡑⢌⠢⣁⠣⡐⢣⠘⢢⡑⠌⡒⢌⡉⢆⡉⢞⠢⣄⠰⡀⠆⠬⡑⢌⠢⡁⠎⢄⠣⡘⠤⠚⡄⢃⠎⡔⢡⠉⣿⣻⢸⣴⠻⠚⢹⣼⣿⡽⣖⣿⢸⡇⠀
#⠀⠀⠀⢀⣿⣸⣿⣿⣿⠐⢢⢉⠢⢡⠐⢢⠑⣂⠉⠆⢐⡡⢘⠠⡘⠤⡘⢄⠣⢄⠃⡜⢨⠑⡌⢢⠑⡌⡘⠤⠑⡌⡘⠡⠘⡄⢊⠄⢣⠘⡈⡏⠃⠀⠀⠀⢸⣿⣿⣷⣭⣿⠀⡇⠀
#⠀⠀⠀⢸⣿⢸⣿⣿⣿⠘⡄⢊⠔⠣⡘⢄⠊⠤⣉⠢⡁⢆⠡⢂⡑⠢⠌⡄⠣⢌⠒⡌⠰⡈⠔⣂⠱⢠⠃⡜⠰⢠⢁⠣⡘⢄⠣⡘⠤⡙⢄⣿⠀⠀⠀⠀⣸⣿⣿⣷⢺⡿⠀⣿⠀
#⠀⠀⠀⣿⣎⣿⣷⣿⣿⠘⡄⠣⢌⠱⠈⢢⠉⢖⠠⡑⢌⠢⡑⠢⢌⠱⢌⠰⢡⠊⡔⢨⠑⡌⡱⢀⠣⢆⠱⣈⠱⡈⢆⠱⡈⢆⠱⣈⠆⡱⢸⣧⠀⠀⠀⠀⠸⣿⣿⢾⣹⡇⢀⢻⠀
#⠀⠀⢰⡇⣧⢹⣿⣿⣽⡗⢨⠑⠊⡆⠑⢢⠉⡆⢣⠉⡆⢱⠈⡅⠊⡔⠊⢱⠈⢱⠈⡆⢱⠐⢡⡍⢲⠈⠒⠀⢣⠘⡄⠓⡌⠘⡔⢢⠘⡄⣿⡌⣷⠀⠀⠀⠀⣾⣿⣮⣽⡇⢠⢸⡇
#⠀⠀⣸⠇⡏⣼⣟⣳⡽⣻⡌⠖⡡⢌⠱⣀⠣⡘⢄⠣⡘⠤⠑⡈⢆⡑⢊⠅⣊⠄⢣⠐⡡⢊⠥⡘⢄⢊⠂⡱⢈⠆⡱⠡⢌⠱⡐⢌⢢⣵⣷⣧⣽⡆⠀⠀⠀⣿⣷⢫⣽⠇⠠⢸⡇
#⠀⠀⣿⠀⣧⢿⡜⣧⣿⡗⢫⡬⡑⢌⠒⡠⢂⠅⡊⠔⡡⢊⡑⠌⠤⡘⢄⠊⡔⠸⣀⠣⡐⢡⢂⠱⡈⢆⠱⣀⠣⡘⠄⠣⢌⠢⡑⣬⢶⣙⣦⣬⡙⣿⠀⠀⠀⣿⣏⣟⣾⢀⠐⢸⡇
#⠀⢠⡏⠄⣿⢯⣽⣚⣿⣻⣄⠴⢋⡶⢅⠒⡡⢊⠔⡡⢂⠣⡘⢌⠢⡑⢌⠒⡨⢑⠤⠑⡌⠒⡌⢢⠑⡌⠒⠤⡑⠌⡌⡑⠢⡁⢮⡙⠇⣠⡿⣷⣽⣟⠀⠀⢀⣿⣞⡼⡏⢀⠀⢺⡇
#⠀⢸⡇⢠⣿⣛⣶⣫⡿⡵⣻⣶⣤⣤⣤⣿⣴⠁⢎⠰⣁⢣⠘⡄⢣⠘⡤⢃⡑⢊⠔⡡⢌⠓⡌⢢⠱⣈⠍⢆⡡⠍⣐⣥⣿⣧⣤⣴⡾⢿⡷⣹⣏⢿⣆⠀⢸⡿⣼⣹⠃⠄⡈⢸⡇
#⠀⢸⡇⢸⣿⡱⢧⡏⣷⣿⣽⣻⠿⣿⡿⣟⡻⢿⣦⢱⡐⢢⠑⡌⢢⠑⢢⠡⡘⢄⠊⡔⡈⠦⣁⠃⠦⡁⢎⣰⣤⣿⢿⣭⢫⣟⡻⣽⣞⣽⣳⢿⢻⣞⣿⠀⢸⣿⣣⡿⠄⠂⠄⢹⡇
#⠀⣸⠇⡼⢧⣛⣿⣷⣿⡿⣾⢷⣫⡳⣝⣲⡽⠛⢹⣿⢿⣶⣥⣢⡁⠎⡄⢣⠘⡄⢣⠐⡡⠒⠤⡉⣆⣵⣾⢿⣿⣟⣆⠙⠳⢾⣵⣿⣿⣿⠉⣾⣿⡿⠁⠀⣼⡿⣵⡇⠠⢁⠂⣼⠃
#⠀⣽⠄⡿⣭⢷⡺⢿⣮⡻⠻⢤⣉⠙⠛⠉⣠⣾⣿⡿⢯⣞⣿⣿⣿⣷⣷⣤⣇⣘⠄⢣⣒⣭⣶⣿⣿⣿⡭⠗⠙⣇⠈⠛⠶⣤⣴⢻⣯⣿⣼⡟⠋⠀⠀⠀⣿⣻⡼⡇⠀⠄⡀⣿⠀
#⠀⣿⢸⡳⡽⣞⡽⣫⣿⠻⣦⣀⣉⡛⠶⠿⠿⠛⠁⠙⢿⢞⣿⣿⣿⣻⣽⣻⣟⣿⣿⣾⣿⣻⣿⣿⣻⡏⠀⠀⠀⠘⢷⣤⣀⠀⠀⠀⣉⣽⠟⠁⠀⠀⠀⠀⣿⡷⣹⠁⠈⠄⣰⡏⠀




import curses, json, os, time, requests, pyperclip
from datetime import datetime, timedelta

import random, string


API_BASE = "https://api.mail.tm"
STORAGE = ".mailtm.json"
DEFAULT_TTL_MIN = 60

# -------------------- API helpers --------------------
def get_domains():
    try:
        r = requests.get(API_BASE + "/domains", timeout=6)
        r.raise_for_status()
        return [x["domain"] for x in r.json().get("hydra:member", [])] or ["mail.tm"]
    except: return ["mail.tm"]

def create_account_local(ttl_minutes=DEFAULT_TTL_MIN):
    domains = get_domains()
    domain = domains[0]
    username = f"user{int(time.time())}"
    email = f"{username}@{domain}"
    password = generate_password(12)  # сложный пароль
    payload = {"address": email, "password": password}
    try:
        r = requests.post(API_BASE + "/accounts", json=payload, timeout=8)
        if r.status_code not in (200, 201):
            return None, f"Ошибка создания аккаунта: {r.status_code}"
    except Exception as e:
        return None, f"Ошибка сети: {e}"

    token = get_token(email, password)
    if not token:
        return None, "Не удалось получить токен."
    now = datetime.utcnow().isoformat()
    data = {
        "email": email,
        "password": password,
        "token": token,
        "created_at": now,
        "ttl_minutes": ttl_minutes
    }
    with open(STORAGE, "w") as f:
        json.dump(data, f)
    return data, None

def get_token(email, password):
    try:
        r = requests.post(API_BASE + "/token", json={"address": email, "password": password}, timeout=8)
        return r.json().get("token") if r.status_code == 200 else None
    except: return None

def load_account():
    if not os.path.exists(STORAGE): return None
    try:
        with open(STORAGE, "r") as f: return json.load(f)
    except: return None

def auth_hdr(acc): return {"Authorization": f"Bearer {acc['token']}"}

def is_expired(acc):
    try:
        created = datetime.fromisoformat(acc["created_at"])
        ttl = int(acc.get("ttl_minutes", DEFAULT_TTL_MIN))
        return datetime.utcnow() > created + timedelta(minutes=ttl)
    except: return False

def fetch_messages(acc):
    if not acc: return [], "Нет аккаунта"
    if is_expired(acc): return [], "Аккаунт истёк (локально)"
    try:
        r = requests.get(API_BASE + "/messages", headers=auth_hdr(acc), timeout=8)
        if r.status_code != 200: return [], f"Ошибка API: {r.status_code}"
        return r.json().get("hydra:member", []), None
    except Exception as e: return [], f"Ошибка сети: {e}"

def fetch_message(acc, msg_id):
    try:
        r = requests.get(f"{API_BASE}/messages/{msg_id}", headers=auth_hdr(acc), timeout=8)
        if r.status_code != 200: return None, f"Ошибка получения письма: {r.status_code}"
        return r.json(), None
    except Exception as e: return None, f"Ошибка сети: {e}"

# ---- ither
def generate_password(length=12):
    chars = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{}|;:,.<>?/~"
    return ''.join(random.choice(chars) for _ in range(length))
    


# -------------------- UI --------------------
def draw_main(stdscr):
    curses.curs_set(0)
    stdscr.nodelay(False)
    stdscr.timeout(1000)
    acc = load_account()
    messages = []
    status = "[i] Готов"
    last_fetch = 0
    selected = 0
    offset = 0
    in_view = False

    while True:
        stdscr.clear()
        h, w = stdscr.getmaxyx()
        stdscr.addstr(0,0," TempMail by d3rrk1a ".center(w,"-"), curses.A_REVERSE)

        # --- Аккаунт и TTL ---
        if acc:
            expired = is_expired(acc)
            ttl = int(acc.get("ttl_minutes", DEFAULT_TTL_MIN))
            created = datetime.fromisoformat(acc["created_at"])
            rem = max(0, int((created + timedelta(minutes=ttl) - datetime.utcnow()).total_seconds()))
            rem_min, rem_sec = divmod(rem, 60)
            bar_len = 20
            filled = int((rem/(ttl*60))*bar_len) if not expired else 0
            bar = "[" + "#"*filled + "-"*(bar_len-filled) + "]"
            header = f"Email: {acc['email']} TTL: {ttl}min {bar} {rem_min}m{rem_sec}s" if not expired else f"Email: {acc['email']} TTL: {ttl}min [EXPIRED]"
            stdscr.addstr(2,1, header[:w-2])

            # строка с паролем
            stdscr.addstr(3,1, f"Generated password: {acc['password']}   (p: копировать)")
        else:
            stdscr.addstr(2,1,"Аккаунт не создан. 'n' для нового.", curses.A_BOLD)

        # --- Навигация ---
        stdscr.addstr(4,1,"↑/↓: выбор  Enter: открыть  r: обновить  n: новый  d: удалить  c: копировать  q: выход")

        # --- Обновление сообщений ---
        now = time.time()
        if acc and not in_view and now - last_fetch > 7:
            messages, err = fetch_messages(acc)
            last_fetch = now
            status = f"[i] {len(messages)} сообщений." if not err else f"[!] {err}"

        # --- Список писем ---
        list_top = 6
        list_height = h - list_top - 4
        stdscr.addstr(list_top-1, 1, "-"*(w-2))
        if not messages: stdscr.addstr(list_top, 2, "(Пусто)")
        else:
            if selected<0: selected=0
            if selected>=len(messages): selected=len(messages)-1
            if selected<offset: offset=selected
            if selected>=offset+list_height: offset=selected-list_height+1
            for idx in range(offset, min(len(messages), offset+list_height)):
                m = messages[idx]
                marker = ">" if idx==selected else " "
                text = f"{marker} {m.get('from')} — {m.get('subject','(no subject)')}"
                try: stdscr.addstr(list_top+idx-offset,1,text[:w-2], curses.A_REVERSE if idx==selected else 0)
                except: pass

        stdscr.addstr(h-2,1,"─"* (w-2))
        stdscr.addstr(h-1,1,status[:w-2])
        stdscr.refresh()

        k = stdscr.getch()
        if k==curses.KEY_DOWN and messages: selected=min(selected+1,len(messages)-1)
        elif k==curses.KEY_UP and messages: selected=max(selected-1,0)
        elif k in (10,13) and messages:
            in_view=True
            stdscr.clear(); stdscr.refresh(); curses.curs_set(0)
            view_message(stdscr, acc, messages[selected]['id'])
            stdscr.clear(); stdscr.refresh(); in_view=False; last_fetch=time.time()
        elif k in (ord('q'),ord('Q')): break
        elif k in (ord('r'),ord('R')) and acc and not in_view:
            messages, err = fetch_messages(acc)
            status = f"[i] Обновлено. {len(messages)} сообщений" if not err else f"[!] {err}"
        elif k in (ord('n'),ord('N')):
            acc_new, err = create_account_local()
            if acc_new: acc=acc_new; messages,_=fetch_messages(acc); selected=offset=0; status=f"[+] Создан: {acc['email']}"
            else: status=f"[!] {err}"
        elif k in (ord('d'),ord('D')) and acc:
            try: os.remove(STORAGE)
            except: pass
            acc=None; messages=[]; selected=offset=0; status="[+] Удалено локально."
        elif k in (ord('c'),ord('C')) and acc:
            pyperclip.copy(acc['email']); status=f"[+] Email {acc['email']} скопирован"
        elif k in (ord('p'), ord('P')) and acc:
            pyperclip.copy(acc['password'])
            status = f"[+] Пароль скопирован в буфер"
            
def view_message(stdscr, acc, msg_id):
    msg, err = fetch_message(acc,msg_id)
    if not msg:
        h,w=stdscr.getmaxyx()
        win=curses.newwin(5,w-4,h//2-2,2)
        win.box(); win.addstr(1,1,f"Ошибка: {err}"); win.addstr(3,1,"Нажмите любую клавишу"); win.refresh(); win.getch(); return
    body = msg.get("text") or msg.get("textBody") or "(пустое тело)"
    attachments = msg.get("attachments", [])
    h,w=stdscr.getmaxyx(); win=curses.newwin(h-4,w-4,2,2); win.keypad(True)
    lines = body.splitlines() + [f"[Attachment] {a.get('filename','unknown')}" for a in attachments]
    sel=0; per_page=h-6; total_pages=max(1,(len(lines)+per_page-1)//per_page); page=0
    os.makedirs("downloads", exist_ok=True)
    while True:
        win.clear(); win.box(); win.addstr(0,2,f" From: {msg.get('from')} | Subject: {msg.get('subject','(no subject)')}")
        start=page*per_page; end=start+per_page
        for i,l in enumerate(lines[start:end]):
            try: win.addstr(1+i,1,l[:w-6],curses.A_REVERSE if start+i==sel and l.startswith("[Attachment]") else 0)
            except: pass
        win.addstr(h-6,1,f"Страница {page+1}/{total_pages} ↑/↓ выбор  ←/→ листать  Enter: скачать")
        win.refresh()
        k=win.getch()
        if k==curses.KEY_DOWN and sel<len(lines)-1: sel+=1; page+=sel//per_page
        elif k==curses.KEY_UP and sel>0: sel-=1; page=sel//per_page
        elif k==curses.KEY_RIGHT and page<total_pages-1: page+=1
        elif k==curses.KEY_LEFT and page>0: page-=1
        elif k in (10,13):
            line=lines[sel]; idx=sel-len(body.splitlines())
            if line.startswith("[Attachment]") and 0<=idx<len(attachments):
                att=attachments[idx]; att_id=att.get("id"); filename=att.get("filename","file")
                if att_id:
                    try:
                        r=requests.get(f"{API_BASE}/messages/{msg_id}/attachments/{att_id}", headers=auth_hdr(acc), timeout=15, stream=True)
                        if r.status_code==200:
                            with open(os.path.join("downloads",filename),"wb") as f:
                                for chunk in r.iter_content(1024): f.write(chunk)
                            win.addstr(h-5,1,f"Скачано: downloads/{filename}   ")
                        else: win.addstr(h-5,1,f"Ошибка скачивания: {r.status_code}")
                    except Exception as e: win.addstr(h-5,1,f"Ошибка: {e}")
                    win.refresh(); time.sleep(1)
        else: break

def main(): curses.wrapper(draw_main)
if __name__=="__main__": main()
