//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⡤⠤⢤⣤⣀⠀⢀⣀⠀⣠⠤⠤⣤⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠶⠛⢉⠁⣀⣤⠠⠀⡀⠄⡀⠈⠉⡀⠀⠄⡥⣤⡀⠉⠛⠶⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠞⠉⠛⠛⠶⣄⡀⢀⣠⠞⠋⢀⠀⣢⠴⠋⡁⠠⠐⠠⠐⠀⡀⠁⢂⠀⠡⠈⠄⡀⠉⠷⣦⠀⠠⠙⠳⣄⡀⠀⠀⠀⠀⠀⣀⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⣸⠇⠀⠈⠤⠁⠂⢈⣭⠚⠁⢀⠂⣠⠞⠅⡀⢂⠐⠁⡈⠄⡾⠁⠀⢷⡀⠌⠠⢁⠂⠄⠡⠀⠌⢡⡀⢡⠀⠀⡙⢦⡀⢀⡴⠛⢉⠀⢈⢃⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠄⣡⠖⠛⢻⠞⠁⠀⠌⢀⡼⠁⠌⡐⠀⠂⢈⠐⢠⠞⠀⠌⢀⠀⠻⣆⡁⠂⡐⢀⠁⡀⠂⠀⠹⣆⠂⡁⢀⠀⣿⣟⠀⠌⠠⠈⡀⠘⣧⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⢸⡇⢀⡼⠃⢈⣴⠋⢀⠂⡁⢂⠞⡀⠁⠂⠄⠡⠈⢀⡴⠃⠀⠀⠀⠀⠄⠀⠘⢧⡐⢀⠀⢂⠐⠠⢁⠀⡘⢧⡐⢀⠂⠘⢞⠷⡤⣅⡐⠠⢀⠸⣇⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⣿⠁⡼⢁⢠⡾⠁⡀⢂⠐⢠⠏⠠⠐⢈⠐⡈⢐⡼⠋⠀⢀⠐⠈⠀⠈⡀⠄⠀⠠⠙⢦⣈⠠⠈⡐⠀⡐⠠⠘⣧⠀⠌⡐⠈⢿⡙⣄⠉⢳⣄⠀⣿⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⣿⢸⠇⢀⣼⠃⢀⠠⠀⠄⣼⠀⠃⠠⠀⠤⣠⣟⣀⠀⠀⠀⠀⠀⠀⠠⠀⠀⢀⠀⡤⠤⠻⣧⡤⠄⠠⠀⢃⠀⢻⡀⠄⡀⢃⠀⢧⡀⢄⠀⢻⣤⢸⡇⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⢰⣧⡟⠀⡾⠁⢀⠂⠄⠁⣸⠁⡀⠂⢷⣴⡋⠐⢀⣨⡷⠀⠈⠀⠀⠀⠀⠀⠐⠀⠺⢥⣠⣁⣀⡹⢦⡥⠈⠄⢂⠀⡇⢂⠐⠀⠂⠘⣧⢸⣆⠠⠀⠈⣷⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⢸⡿⠀⣸⠃⢀⠂⠠⢈⢠⡏⠠⢐⡴⠋⠀⠈⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀⢀⠀⠀⡀⠀⠠⠀⠀⠙⠳⣌⠠⠀⢻⢀⠀⠂⠁⠄⠘⢺⣿⣄⠈⠄⢿⡄⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⢸⠇⢠⠇⠀⠂⠄⡁⠂⣸⣠⠔⠋⠀⠀⡀⠐⣄⣀⣂⠀⠀⠠⠐⠀⠀⠄⠂⠁⡀⢀⡥⠖⣒⣀⣁⣴⠂⠀⠈⠳⢦⣸⠀⢂⠡⢈⠠⠈⢸⡏⣟⡄⠠⠸⣇⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⣿⠀⡟⠀⠌⡐⠀⡂⠁⣿⠁⠀⣀⣷⣦⣿⣷⣶⣶⣬⣙⠀⠀⠂⠀⠀⡀⠌⠀⡀⠠⠶⣻⣿⣿⣿⣿⣿⣷⣦⣤⠤⢹⠀⢂⠐⡀⢂⠡⠀⣧⣯⣧⠐⠀⣿⠀⠀⠀
//⠀⠀⠀⠀⠀⢸⡇⢸⢣⠈⠀⠄⡁⠄⢶⣿⣳⡾⠋⣱⣿⣿⣿⣿⣿⣿⣮⠁⠀⠁⠈⠀⠀⠠⠀⠀⠀⣼⣿⡿⣿⣻⠿⣿⣿⡌⠻⣷⣾⠆⠂⠐⠀⢂⠐⡀⢻⣿⣻⡄⠀⠹⠆⠀⠀
//⠀⠀⠀⠀⠀⣼⠀⡟⡏⠐⠈⢀⠀⠂⠄⢿⠻⠆⠀⢿⡟⠁⠻⠞⢁⣹⠟⠀⠀⠠⠀⠖⠀⢀⠀⠄⠀⠙⠿⢠⣭⣍⣠⣸⠟⠁⡈⢡⡇⠀⠐⠀⡈⠀⢂⢐⢸⣿⣳⣧⣈⣐⣀⡀⠀
//⠀⠀⠀⠀⠀⡟⢸⡇⡇⢈⠐⡀⢠⡂⠄⠸⡇⡐⢈⢤⢉⡉⠩⢉⠁⡀⠀⠀⠀⠄⠐⠀⡐⠀⡀⠀⠈⠠⠐⢠⠠⡢⢅⡦⢨⠐⢀⡞⢀⠈⡐⠠⠐⢈⠀⢸⢸⡏⠉⠉⠉⢉⣉⣉⣉
//⠖⠒⠒⠚⠓⠛⢹⢃⡇⠂⠄⡐⠈⣷⡈⠄⢻⡄⢂⢎⠲⢉⠒⡀⢂⠐⠀⠂⢁⠠⠈⠀⠀⠄⢀⡄⠈⠄⢁⠂⡐⡁⠎⡔⠡⢈⡞⢠⡿⠀⠄⠡⠈⠄⠈⡿⢸⣷⣞⢿⡻⣟⡻⣏⡟
//⢿⡻⢿⣻⢶⡶⣾⠄⡇⢐⠀⡀⠡⠈⢷⣦⣀⣹⢦⠀⠅⢊⠐⠀⡀⠂⠀⠀⢈⠙⠓⠀⠘⠛⠉⠀⠠⢈⠀⠄⠐⠀⢂⠐⠰⡭⠖⢳⠇⣸⠂⠁⠌⠐⣸⠇⣾⢳⡎⣷⡹⠎⠓⠉⠈
//⣳⣝⢧⣛⢮⡳⣽⡆⣿⠨⣇⣠⠶⡛⠭⡉⣍⠹⣈⠛⡛⠶⢦⣅⡀⠀⢀⠀⠂⠀⠀⠡⠀⠂⠀⢈⣤⠶⢖⡛⣋⠚⡉⢇⡙⠆⡤⢷⢾⡇⠐⢨⠀⣴⡿⢠⡟⢋⠉⢁⣀⣤⣤⠶⠒         by d3rrk1a
//⠶⢤⣬⠉⠙⠛⠻⣇⠘⢣⡞⡡⢎⠰⡑⠰⣀⠣⢄⠣⡘⢌⠒⡌⠛⢷⣤⠀⠀⠄⠂⡀⠁⣠⡾⢋⠆⣉⠆⡰⢁⠚⣈⠆⣘⠰⢌⠢⡙⢧⡞⢁⣾⡇⢁⣾⡟⣿⣟⡟⣯⣻⢸⠀⠀             <3
//⠀⠀⠀⠀⣽⢉⣿⣿⣶⡟⠤⡑⢌⠢⣁⠣⡐⢣⠘⢢⡑⠌⡒⢌⡉⢆⡉⢞⠢⣄⠰⡀⠆⠬⡑⢌⠢⡁⠎⢄⠣⡘⠤⠚⡄⢃⠎⡔⢡⠉⣿⣻⢸⣴⠻⠚⢹⣼⣿⡽⣖⣿⢸⡇⠀
//⠀⠀⠀⢀⣿⣸⣿⣿⣿⠐⢢⢉⠢⢡⠐⢢⠑⣂⠉⠆⢐⡡⢘⠠⡘⠤⡘⢄⠣⢄⠃⡜⢨⠑⡌⢢⠑⡌⡘⠤⠑⡌⡘⠡⠘⡄⢊⠄⢣⠘⡈⡏⠃⠀⠀⠀⢸⣿⣿⣷⣭⣿⠀⡇⠀
//⠀⠀⠀⢸⣿⢸⣿⣿⣿⠘⡄⢊⠔⠣⡘⢄⠊⠤⣉⠢⡁⢆⠡⢂⡑⠢⠌⡄⠣⢌⠒⡌⠰⡈⠔⣂⠱⢠⠃⡜⠰⢠⢁⠣⡘⢄⠣⡘⠤⡙⢄⣿⠀⠀⠀⠀⣸⣿⣿⣷⢺⡿⠀⣿⠀
//⠀⠀⠀⣿⣎⣿⣷⣿⣿⠘⡄⠣⢌⠱⠈⢢⠉⢖⠠⡑⢌⠢⡑⠢⢌⠱⢌⠰⢡⠊⡔⢨⠑⡌⡱⢀⠣⢆⠱⣈⠱⡈⢆⠱⡈⢆⠱⣈⠆⡱⢸⣧⠀⠀⠀⠀⠸⣿⣿⢾⣹⡇⢀⢻⠀
//⠀⠀⢰⡇⣧⢹⣿⣿⣽⡗⢨⠑⠊⡆⠑⢢⠉⡆⢣⠉⡆⢱⠈⡅⠊⡔⠊⢱⠈⢱⠈⡆⢱⠐⢡⡍⢲⠈⠒⠀⢣⠘⡄⠓⡌⠘⡔⢢⠘⡄⣿⡌⣷⠀⠀⠀⠀⣾⣿⣮⣽⡇⢠⢸⡇
//⠀⠀⣸⠇⡏⣼⣟⣳⡽⣻⡌⠖⡡⢌⠱⣀⠣⡘⢄⠣⡘⠤⠑⡈⢆⡑⢊⠅⣊⠄⢣⠐⡡⢊⠥⡘⢄⢊⠂⡱⢈⠆⡱⠡⢌⠱⡐⢌⢢⣵⣷⣧⣽⡆⠀⠀⠀⣿⣷⢫⣽⠇⠠⢸⡇
//⠀⠀⣿⠀⣧⢿⡜⣧⣿⡗⢫⡬⡑⢌⠒⡠⢂⠅⡊⠔⡡⢊⡑⠌⠤⡘⢄⠊⡔⠸⣀⠣⡐⢡⢂⠱⡈⢆⠱⣀⠣⡘⠄⠣⢌⠢⡑⣬⢶⣙⣦⣬⡙⣿⠀⠀⠀⣿⣏⣟⣾⢀⠐⢸⡇
//⠀⢠⡏⠄⣿⢯⣽⣚⣿⣻⣄⠴⢋⡶⢅⠒⡡⢊⠔⡡⢂⠣⡘⢌⠢⡑⢌⠒⡨⢑⠤⠑⡌⠒⡌⢢⠑⡌⠒⠤⡑⠌⡌⡑⠢⡁⢮⡙⠇⣠⡿⣷⣽⣟⠀⠀⢀⣿⣞⡼⡏⢀⠀⢺⡇
//⠀⢸⡇⢠⣿⣛⣶⣫⡿⡵⣻⣶⣤⣤⣤⣿⣴⠁⢎⠰⣁⢣⠘⡄⢣⠘⡤⢃⡑⢊⠔⡡⢌⠓⡌⢢⠱⣈⠍⢆⡡⠍⣐⣥⣿⣧⣤⣴⡾⢿⡷⣹⣏⢿⣆⠀⢸⡿⣼⣹⠃⠄⡈⢸⡇
//⠀⢸⡇⢸⣿⡱⢧⡏⣷⣿⣽⣻⠿⣿⡿⣟⡻⢿⣦⢱⡐⢢⠑⡌⢢⠑⢢⠡⡘⢄⠊⡔⡈⠦⣁⠃⠦⡁⢎⣰⣤⣿⢿⣭⢫⣟⡻⣽⣞⣽⣳⢿⢻⣞⣿⠀⢸⣿⣣⡿⠄⠂⠄⢹⡇
//⠀⣸⠇⡼⢧⣛⣿⣷⣿⡿⣾⢷⣫⡳⣝⣲⡽⠛⢹⣿⢿⣶⣥⣢⡁⠎⡄⢣⠘⡄⢣⠐⡡⠒⠤⡉⣆⣵⣾⢿⣿⣟⣆⠙⠳⢾⣵⣿⣿⣿⠉⣾⣿⡿⠁⠀⣼⡿⣵⡇⠠⢁⠂⣼⠃
//⠀⣽⠄⡿⣭⢷⡺⢿⣮⡻⠻⢤⣉⠙⠛⠉⣠⣾⣿⡿⢯⣞⣿⣿⣿⣷⣷⣤⣇⣘⠄⢣⣒⣭⣶⣿⣿⣿⡭⠗⠙⣇⠈⠛⠶⣤⣴⢻⣯⣿⣼⡟⠋⠀⠀⠀⣿⣻⡼⡇⠀⠄⡀⣿⠀
//⠀⣿⢸⡳⡽⣞⡽⣫⣿⠻⣦⣀⣉⡛⠶⠿⠿⠛⠁⠙⢿⢞⣿⣿⣿⣻⣽⣻⣟⣿⣿⣾⣿⣻⣿⣿⣻⡏⠀⠀⠀⠘⢷⣤⣀⠀⠀⠀⣉⣽⠟⠁⠀⠀⠀⠀⣿⡷⣹⠁⠈⠄⣰⡏⠀




use std::{
    fs::{self, File},
    io::{self, Write},
    path::Path,
    time::Duration,
};

use chrono::{DateTime, Utc, Duration as ChronoDuration};
use copypasta::{ClipboardContext, ClipboardProvider};
use rand::{distributions::Alphanumeric, Rng};
use reqwest::blocking::Client;
use serde::{Deserialize, Serialize};
use tui::{
    backend::Backend,
    backend::CrosstermBackend,
    layout::{Constraint, Direction, Layout},
    style::{Color, Modifier, Style},
    text::{Span, Spans},
    widgets::{Block, Borders, List, ListItem, Paragraph, Wrap},
    Terminal,
    widgets::ListState,
};
use crossterm::{
    event::{self, Event, KeyCode, EnableMouseCapture, DisableMouseCapture},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};

use std::thread;
use std::process::{Command, Stdio};

use scraper::{Html, Selector};
use serde_json::Value;
use html2text;



// ---------------- Types ----------------

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Account {
    email: String,
    password: String,
    token: String,
    created_at: DateTime<Utc>,
    ttl_minutes: i64,
}

#[derive(Deserialize, Debug)]
struct DomainList {
    #[serde(rename = "hydra:member")]
    member: Vec<DomainItem>,
}

#[derive(Deserialize, Debug)]
struct DomainItem {
    domain: String,
}

#[derive(Deserialize, Debug, Clone)]
struct Attachment {
    id: String,
    filename: String,
}

#[derive(Deserialize, Debug, Clone)]
struct Message {
    id: String,
    #[serde(rename = "from")]
    from_field: Option<FromField>,
    subject: Option<String>,
    text: Option<String>,
    html: Option<String>, // добавили
    #[serde(default)]
    attachments: Vec<Attachment>,
}

#[derive(Deserialize, Debug, Clone)]
struct FromField {
    address: String,
}

#[derive(Deserialize, Debug)]
struct MessageList {
    #[serde(rename = "hydra:member")]
    member: Vec<Message>,
}

// ---------------- Constants ----------------

const API_BASE: &str = "https://api.mail.tm";
const STORAGE: &str = ".mailtm.json";
const DEFAULT_TTL_MIN: i64 = 60;

// ---------------- Helpers ----------------
fn copy_to_clipboard(text: &str) -> bool {
    // Попробуем wl-copy (Wayland)
    if Command::new("wl-copy")
        .stdin(Stdio::piped())
        .spawn()
        .and_then(|mut child| {
            child.stdin.as_mut().unwrap().write_all(text.as_bytes())?;
            child.wait()?;
            Ok(())
        })
        .is_ok()
    {
        return true;
    }

    // Попробуем xclip (X11)
    if Command::new("xclip")
        .args(&["-selection", "clipboard"])
        .stdin(Stdio::piped())
        .spawn()
        .and_then(|mut child| {
            child.stdin.as_mut().unwrap().write_all(text.as_bytes())?;
            child.wait()?;
            Ok(())
        })
        .is_ok()
    {
        return true;
    }

    false // не удалось скопировать
}


fn fetch_full_message_body(client: &Client, acc: &Account, msg_id: &str) -> String {
    let url = format!("{}/messages/{}", API_BASE, msg_id);
    let resp = match client.get(&url).bearer_auth(&acc.token).send() {
        Ok(r) => r,
        Err(_) => return "(error fetching message)".to_string(),
    };

    if !resp.status().is_success() {
        return "(error fetching message)".to_string();
    }

    let full_msg: Value = match resp.json() {
        Ok(v) => v,
        Err(_) => return "(error parsing message)".to_string(),
    };

    // Сначала plain text
    if let Some(text) = full_msg.get("text").and_then(|t| t.as_str()) {
        if !text.is_empty() {
            return text.to_string();
        }
    }

    // Потом html
    if let Some(html) = full_msg.get("html").and_then(|h| h.as_str()) {
        if !html.is_empty() {
            // Парсим body через scraper
            let document = Html::parse_document(html);
            let selector = Selector::parse("body").unwrap();
            let mut body_text = String::new();
            for elem in document.select(&selector) {
                body_text.push_str(&elem.text().collect::<Vec<_>>().join("\n"));
            }

            if !body_text.is_empty() {
                return body_text;
            } else {
                // fallback на html2text
                return html2text::from_read(html.as_bytes(), 10000)
                    .unwrap_or("(no text)".to_string());
            }
        }
    }

    "(no text)".to_string()
}



fn generate_password(len: usize) -> String {
    let charset = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\
                    abcdefghijklmnopqrstuvwxyz\
                    0123456789!@#$%^&*()-_=+[]{};:,.<>?";
    let mut rng = rand::thread_rng();
    (0..len)
        .map(|_| {
            let idx = rng.gen_range(0..charset.len());
            charset[idx] as char
        })
        .collect()
}


fn save_account(acc: &Account) -> io::Result<()> {
    let file = File::create(STORAGE)?;
    serde_json::to_writer_pretty(file, acc)?;
    Ok(())
}

fn load_account() -> Option<Account> {
    if !Path::new(STORAGE).exists() {
        return None;
    }
    let file = File::open(STORAGE).ok()?;
    serde_json::from_reader(file).ok()
}

fn get_domains(client: &Client) -> Vec<String> {
    match client.get(&format!("{}/domains", API_BASE)).send() {
        Ok(resp) => resp
            .json::<DomainList>()
            .map(|dl| dl.member.into_iter().map(|d| d.domain).collect())
            .unwrap_or(vec!["mail.tm".to_string()]),
        Err(_) => vec!["mail.tm".to_string()],
    }
}

fn get_token(client: &Client, email: &str, password: &str) -> Option<String> {
    let payload = serde_json::json!({ "address": email, "password": password });
    let resp = client.post(&format!("{}/token", API_BASE)).json(&payload).send().ok()?;
    if resp.status().is_success() {
        let v: serde_json::Value = resp.json().ok()?;
        return v.get("token").and_then(|t| t.as_str()).map(String::from);
    }
    None
}

fn create_account_local(client: &Client, ttl_minutes: i64) -> Option<Account> {
    let domains = get_domains(client);
    let domain = &domains[0];
    let username = format!("user{}", Utc::now().timestamp());
    let email = format!("{}@{}", username, domain);
    let password = generate_password(12);
    let payload = serde_json::json!({ "address": email, "password": password });

    let resp = client.post(&format!("{}/accounts", API_BASE)).json(&payload).send().ok()?;
    if !resp.status().is_success() {
        return None;
    }

    let token = get_token(client, &email, &password)?;
    let acc = Account {
        email,
        password,
        token,
        created_at: Utc::now(),
        ttl_minutes,
    };
    save_account(&acc).ok()?;
    Some(acc)
}

fn is_expired(acc: &Account) -> bool {
    let expiry = acc.created_at + ChronoDuration::minutes(acc.ttl_minutes);
    Utc::now() > expiry
}

fn fetch_messages(client: &Client, acc: &Account) -> Vec<Message> {
    let resp = client
        .get(&format!("{}/messages", API_BASE))
        .bearer_auth(&acc.token)
        .send();
    if let Ok(r) = resp {
        if r.status().is_success() {
            if let Ok(ml) = r.json::<MessageList>() {
                return ml.member;
            }
        }
    }
    vec![]
}

fn view_message<B: Backend>(
    terminal: &mut Terminal<B>,
    client: &Client,
    acc: &Account,
    msg: &Message,
) -> Result<(), Box<dyn std::error::Error>> {
    use std::time::Duration;
    use crossterm::event::{self, Event, KeyCode};

    // Берём либо plain text, либо html, либо показываем заглушку
    let body = fetch_full_message_body(client, acc, &msg.id);

    let mut scroll: u16 = 0; // текущая вертикальная прокрутка

    loop {
        terminal.draw(|f| {
            let size = f.size();

            // Заголовок письма
            let block = Block::default()
                .borders(Borders::ALL)
                .title(msg.subject.clone().unwrap_or("(no subject)".to_string()));

            // Отображение тела письма с прокруткой
            let paragraph = Paragraph::new(body.clone())
                .block(block)
                .wrap(Wrap { trim: true })
                .scroll((scroll, 0)); // прокрутка по вертикали

            f.render_widget(paragraph, size);
        })?;

        // Обработка клавиш
        if event::poll(Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                match key.code {
                    KeyCode::Esc => break,            // выход из письма
                    KeyCode::Up => {
                        if scroll > 0 {
                            scroll -= 1;
                        }
                    }
                    KeyCode::Down => {
                        scroll = scroll.saturating_add(1); // добавляем проверку через saturating_add
                    }
                    _ => {}
                }
            }
        }
    }

    Ok(())
}





// ---------------- TUI ----------------
fn main() -> Result<(), Box<dyn std::error::Error>> {
    use std::{fs, thread, time::Duration};
    use crossterm::{
        execute,
        terminal::{EnterAlternateScreen, LeaveAlternateScreen, enable_raw_mode, disable_raw_mode},
        event::{self, Event, KeyCode, EnableMouseCapture, DisableMouseCapture},
    };
    use tui::{
        backend::CrosstermBackend,
        widgets::{Block, Borders, List, ListItem, ListState, Paragraph, Wrap},
        layout::{Layout, Constraint, Direction},
        style::{Style, Modifier, Color},
        Terminal,
    };
    use copypasta::{ClipboardContext, ClipboardProvider};
    use chrono::{Utc, Duration as ChronoDuration};

    // Инициализация терминала
    enable_raw_mode()?;
    let mut stdout = std::io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    // Основные переменные
    let client = Client::new();
    let mut acc = load_account();
    let mut messages: Vec<Message> = if let Some(acc_ref) = &acc {
        fetch_messages(&client, acc_ref)
    } else { vec![] };
    let mut status = "[i] Готов".to_string();
    let mut list_state = ListState::default();
    list_state.select(Some(0));

    loop {
        terminal.draw(|f| {
            let size = f.size();
            let chunks = Layout::default()
                .direction(Direction::Vertical)
                .margin(1)
                .constraints([
                    Constraint::Length(4),  // Account info
                    Constraint::Length(3),  // Navigation — увеличил с 2 → 3
                    Constraint::Min(5),     // Messages list
                ].as_ref())
                .split(size);

            // Account info
            let header_text = if let Some(acc_ref) = &acc {
                let expired = is_expired(acc_ref);
                let ttl_sec = acc_ref.ttl_minutes * 60;
                let rem = (acc_ref.created_at + ChronoDuration::minutes(acc_ref.ttl_minutes) - Utc::now()).num_seconds().max(0);
                let filled = ((rem as f64 / ttl_sec as f64) * 20.0).round() as usize;
                let bar = format!("[{}{}]", "#".repeat(filled), "-".repeat(20 - filled));
                let ttl_info = if !expired {
                    format!("{}m{}s", rem / 60, rem % 60)
                } else {
                    "[EXPIRED]".to_string()
                };
                vec![
                    format!("Email: {} TTL: {}min {} {}", acc_ref.email, acc_ref.ttl_minutes, bar, ttl_info),
                    format!("Generated password: {}", acc_ref.password)
                ]
            } else {
                vec!["Account not exist`s. N: create a new mail".to_string()]
            };
            let paragraph = Paragraph::new(header_text.join("\n"))
                .block(Block::default().borders(Borders::ALL).title("Account"))
                .wrap(Wrap { trim: true });
            f.render_widget(paragraph, chunks[0]);

            // Navigation
            let nav = Paragraph::new("↑/↓: choice  Enter: open mail  r: update  n: new mail  d: delete acc  c: copy email  p: copy password  q: exit")
                .block(Block::default().borders(Borders::ALL).title("Navigation"))
                .wrap(Wrap { trim: true });  // ← добавляем wrap
            f.render_widget(nav, chunks[1]);

            // Messages list
            let list_items: Vec<ListItem> = messages.iter().map(|m| {
                let subject = m.subject.clone().unwrap_or("(no subject)".to_string());
                let from = m.from_field.as_ref().map(|f| f.address.clone()).unwrap_or("(unknown)".to_string());
                ListItem::new(format!("{} — {}", from, subject))
            }).collect();
            let list = List::new(list_items)
                .block(Block::default().borders(Borders::ALL).title(status.as_str()))
                .highlight_style(Style::default().bg(Color::Blue).fg(Color::White).add_modifier(Modifier::BOLD))
                .highlight_symbol(">");
            f.render_stateful_widget(list, chunks[2], &mut list_state);
        })?;

        // События
        if event::poll(Duration::from_millis(200))? {
            if let Event::Key(key) = event::read()? {
                match key.code {
                    KeyCode::Char('q') => break,
                    KeyCode::Char('n') => {
                        if let Some(new_acc) = create_account_local(&client, DEFAULT_TTL_MIN) {
                            acc = Some(new_acc.clone());
                            messages = fetch_messages(&client, &new_acc);
                            status = format!("[+] Создан: {}", new_acc.email);
                            list_state.select(Some(0));
                        }
                    }
                    KeyCode::Char('r') => {
                        if let Some(acc_ref) = &acc {
                            messages = fetch_messages(&client, acc_ref);
                            status = format!("[i] {} сообщений", messages.len());
                            list_state.select(Some(0));
                        }
                    }
                    KeyCode::Char('d') => {
                        let _ = fs::remove_file(STORAGE);
                        acc = None;
                        messages.clear();
                        status = "[+] Удалено локально".to_string();
                        list_state.select(None);
                    }
                    KeyCode::Char('c') => {
                        if let Some(acc_ref) = &acc {
                            if copy_to_clipboard(&acc_ref.email) {
                                status = "[+] Email скопирован".to_string();
                            } else {
                                status = "[!] Не удалось скопировать email".to_string();
                            }
                        }
                    }

                    KeyCode::Char('p') => {
                        if let Some(acc_ref) = &acc {
                            if copy_to_clipboard(&acc_ref.password) {
                                status = "[+] Пароль скопирован".to_string();
                            } else {
                                status = "[!] Не удалось скопировать пароль".to_string();
                            }
                        }
                    }




                    KeyCode::Up => {
                        if let Some(i) = list_state.selected() {
                            if i > 0 { list_state.select(Some(i - 1)); }
                        }
                    }
                    KeyCode::Down => {
                        if let Some(i) = list_state.selected() {
                            if i + 1 < messages.len() { list_state.select(Some(i + 1)); }
                        }
                    }
                    KeyCode::Enter => {
                        if let Some(i) = list_state.selected() {
                            if let Some(msg) = messages.get(i) {
                                view_message(&mut terminal, &client, acc.as_ref().unwrap(), msg)?;
                            }

                        }
                    }
                    _ => {}
                }
            }
        }
    }

    // Выход из терминала
    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen, DisableMouseCapture)?;
    terminal.show_cursor()?;
    Ok(())
}
